<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Foundry VTT Map Forge: Ultimate Edition</title>
    <style>
        :root {
            --bg-dark: #121212;
            --panel-bg: rgba(20, 20, 20, 0.95);
            --text-main: #e0e0e0;
            --text-muted: #888;
            --accent: #ff9800; /* Orange/Gold for "Forge" feel */
            --accent-hover: #ffb74d;
            --border: #333;
            --input-bg: #222;
            --success: #4caf50;
        }

        * { box-sizing: border-box; user-select: none; outline: none; }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        /* --- Viewport --- */
        #viewport {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            background-color: #050505;
            cursor: grab;
        }
        #viewport:active { cursor: grabbing; }
        
        canvas { display: block; }

        /* --- UI Sidebar --- */
        .sidebar {
            width: 340px;
            background-color: var(--panel-bg);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
            box-shadow: 5px 0 20px rgba(0,0,0,0.5);
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(to bottom, #252525, #1a1a1a);
        }

        h1 { margin: 0; font-size: 1.2rem; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; }
        .subtitle { font-size: 0.75rem; color: var(--text-muted); margin-top: 4px; }

        .sidebar-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* --- Controls --- */
        .control-group {
            background: rgba(255,255,255,0.02);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #2a2a2a;
        }

        .group-title {
            font-size: 0.7rem;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 8px;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .row { display: flex; gap: 10px; align-items: center; margin-bottom: 8px; }
        .row > * { flex: 1; }
        .row.tight { margin-bottom: 4px; }

        label { font-size: 0.8rem; color: var(--text-main); }
        
        input[type="text"], input[type="number"], select {
            background: var(--input-bg);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 6px 8px;
            border-radius: 4px;
            width: 100%;
            font-size: 0.85rem;
        }
        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            border-color: var(--accent);
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #444;
            border-radius: 2px;
            appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 14px; height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        /* --- Toggle Switch --- */
        .toggle-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .switch {
            position: relative; display: inline-block; width: 34px; height: 18px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #444; transition: .4s; border-radius: 18px;
        }
        .slider:before {
            position: absolute; content: ""; height: 14px; width: 14px; left: 2px; bottom: 2px;
            background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--accent); }
        input:checked + .slider:before { transform: translateX(16px); }

        /* --- Accordion --- */
        .accordion {
            cursor: pointer;
            padding: 8px;
            width: 100%;
            text-align: left;
            background: #222;
            color: var(--text-main);
            border: none;
            outline: none;
            transition: 0.4s;
            font-size: 0.8rem;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .active, .accordion:hover { background-color: #333; }
        .accordion:after { content: '\002B'; font-weight: bold; }
        .active:after { content: "\2212"; }
        .panel {
            padding: 0 10px;
            background-color: rgba(0,0,0,0.2);
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.2s ease-out;
            border-radius: 0 0 4px 4px;
        }

        /* --- Buttons --- */
        .btn-primary {
            background-color: var(--accent);
            color: #000;
            border: none;
            padding: 12px;
            font-weight: bold;
            width: 100%;
            cursor: pointer;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: filter 0.2s;
        }
        .btn-primary:hover { filter: brightness(1.1); }
        
        .btn-secondary {
            background: #333; color: #fff; border: none; padding: 8px;
            border-radius: 4px; cursor: pointer; font-size: 0.8rem;
        }
        .btn-secondary:hover { background: #444; }

        /* --- Status Bar --- */
        .status-bar {
            padding: 10px 20px;
            border-top: 1px solid var(--border);
            font-size: 0.75rem;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
        }

        /* --- Color Palette Preview --- */
        .palette-option {
            display: inline-block; width: 20px; height: 20px; border-radius: 50%; margin-right: 5px; border: 1px solid #555; cursor: pointer;
        }
        .palette-option.selected { border-color: white; box-shadow: 0 0 5px white; }

    </style>
</head>
<body>

    <div class="sidebar">
        <div class="sidebar-header">
            <h1>Map Forge</h1>
            <div class="subtitle">Ultimate Procedural Engine</div>
        </div>

        <div class="sidebar-content">
            <!-- Main Generation -->
            <div class="control-group">
                <div class="group-title">Core Settings</div>
                <div class="row">
                    <select id="biomeSelect">
                        <option value="dungeon">Dungeon (BSP)</option>
                        <option value="cavern">Cavern (Organic)</option>
                        <option value="town">Town (Complex)</option>
                        <option value="ruins">Ancient Ruins</option>
                    </select>
                </div>
                <div class="row">
                    <label>Size (Tiles):</label>
                    <input type="number" id="mapSize" value="100" min="40" max="300" step="10">
                </div>
                <div class="row">
                    <label>Corridor Width:</label>
                    <input type="range" id="corridorWidth" min="1" max="5" value="2">
                    <span id="corridorVal" style="font-size:0.8rem; width:20px;">2</span>
                </div>
                <div class="row">
                    <input type="text" id="seedInput" placeholder="Seed (Optional)">
                    <button class="btn-secondary" id="rndSeedBtn">ðŸŽ²</button>
                </div>
            </div>

            <!-- Advanced Accordion -->
            <button class="accordion">Advanced Config</button>
            <div class="panel">
                <br>
                <div class="row">
                    <label>Grid Size (px):</label>
                    <input type="number" id="tileSize" value="64" min="32" max="128">
                </div>
                <div class="toggle-row">
                    <label>Show Roofs (Town)</label>
                    <label class="switch">
                        <input type="checkbox" id="showRoofs" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="toggle-row">
                    <label>Show Grid</label>
                    <label class="switch">
                        <input type="checkbox" id="showGrid" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="toggle-row">
                    <label>Dynamic Lighting</label>
                    <label class="switch">
                        <input type="checkbox" id="enableLighting" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="row">
                    <label>Water Level:</label>
                    <input type="range" id="waterLevel" min="0" max="100" value="0">
                </div>
            </div>

            <!-- Theme Selector -->
            <div class="control-group">
                <div class="group-title">Theme</div>
                <select id="themeSelect">
                    <option value="classic">Classic Stone</option>
                    <option value="obsidian">Obsidian Dark</option>
                    <option value="sandstone">Desert Sandstone</option>
                    <option value="jungle">Mossy Jungle</option>
                </select>
            </div>

            <!-- Actions -->
            <button id="generateBtn" class="btn-primary">Generate Map</button>
            
            <div class="row" style="margin-top: 10px;">
                <button id="exportBtn" class="btn-secondary">ðŸ’¾ Export WebP</button>
                <button id="jsonBtn" class="btn-secondary">ðŸ“‹ JSON</button>
            </div>
        </div>

        <div class="status-bar">
            <span id="statusText">Ready</span>
            <span id="perfText">60 FPS</span>
        </div>
    </div>

    <div id="viewport">
        <!-- Main Display Canvas -->
        <canvas id="mainCanvas"></canvas>
    </div>

    <script>
        /**
         * FOUNDRY MAP FORGE: ULTIMATE EDITION
         * Highly optimized, layered rendering map generator.
         */

        // --- Constants & Config ---
        const TILE = {
            VOID: 0, FLOOR: 1, WALL: 2, DOOR: 3, WATER: 4, GRASS: 5, ROAD: 6, BRIDGE: 7
        };

        // Color Themes
        const THEMES = {
            classic: { floor: '#2a2a2a', wall: '#111', wallTop: '#444', grass: '#2d3a26', water: '#264b62', road: '#524b42' },
            obsidian: { floor: '#1a1015', wall: '#000', wallTop: '#2d1b2e', grass: '#1f221b', water: '#3e1c1c', road: '#2a2a2a' },
            sandstone: { floor: '#d4b483', wall: '#5d4037', wallTop: '#8d6e63', grass: '#8c9e5e', water: '#4fc3f7', road: '#a1887f' },
            jungle: { floor: '#3e4435', wall: '#1b2614', wallTop: '#4b5c3d', grass: '#1e3612', water: '#2e5a4e', road: '#5c5546' }
        };

        const STATE = {
            config: {
                size: 100,
                tileSize: 64,
                seed: 'forge',
                biome: 'dungeon',
                theme: 'classic',
                corridorWidth: 2,
                waterLevel: 0,
                showRoofs: true,
                enableLighting: true,
                showGrid: true
            },
            map: [], // 2D array of Tiles
            heightMap: [], // 0-1 float
            entities: [], // Objects {type, x, y, w, h, color, ...}
            rooms: [], // Objects {x, y, w, h, type}
            lights: [], // Objects {x, y, color, radius, flicker}
            
            // Camera
            cam: { x: 0, y: 0, z: 1 },
            isDragging: false,
            lastMouse: { x: 0, y: 0 }
        };

        // --- Offscreen Buffers (The "Mega-Map" Optimization) ---
        // We render the static map (floor, walls, water) to this invisible canvas ONCE.
        const staticCanvas = document.createElement('canvas');
        const staticCtx = staticCanvas.getContext('2d', { alpha: false }); // Alpha false for speed

        const mainCanvas = document.getElementById('mainCanvas');
        const ctx = mainCanvas.getContext('2d', { alpha: false });

        // --- Random Generator (Seeded) ---
        let rng = Math.random;
        function setSeed(str) {
            let h = 2166136261 >>> 0;
            for (let i = 0; i < str.length; i++) {
                h = Math.imul(h ^ str.charCodeAt(i), 16777619);
            }
            rng = function() {
                h += h << 13; h ^= h >>> 7;
                h += h << 3;  h ^= h >>> 17;
                return (h >>> 0) / 4294967296;
            }
        }

        // --- Initialization ---
        function init() {
            window.addEventListener('resize', resizeViewport);
            setupControls();
            resizeViewport();
            generate();
            loop();
        }

        function resizeViewport() {
            mainCanvas.width = document.getElementById('viewport').clientWidth;
            mainCanvas.height = document.getElementById('viewport').clientHeight;
        }

        // --- Generation Pipeline ---
        function generate() {
            const t0 = performance.now();
            document.getElementById('statusText').innerText = "Forging World...";
            
            // 1. Config Setup
            updateConfigFromUI();
            setSeed(STATE.config.seed);

            // 2. Initialize Arrays
            const sz = STATE.config.size;
            STATE.map = Array(sz).fill(0).map(() => Array(sz).fill(TILE.VOID));
            STATE.heightMap = Array(sz).fill(0).map(() => Array(sz).fill(0));
            STATE.entities = [];
            STATE.rooms = [];
            STATE.lights = [];

            // 3. Biome Algorithm
            switch(STATE.config.biome) {
                case 'dungeon': genDungeon(); break;
                case 'cavern': genCavern(); break;
                case 'town': genTown(); break;
                case 'ruins': genRuins(); break;
            }

            // 4. Water Pass
            if (STATE.config.waterLevel > 0) applyWater();

            // 5. Render Static Layer (Expensive)
            renderStaticLayer();

            const t1 = performance.now();
            console.log(`Generation took ${Math.round(t1-t0)}ms`);
            document.getElementById('statusText').innerText = `Ready (${sz}x${sz})`;

            // Center Camera
            STATE.cam.x = -(sz * STATE.config.tileSize) / 2 + mainCanvas.width / 2;
            STATE.cam.y = -(sz * STATE.config.tileSize) / 2 + mainCanvas.height / 2;
            STATE.cam.z = 0.5; // Zoom out a bit initially
        }

        function updateConfigFromUI() {
            STATE.config.biome = document.getElementById('biomeSelect').value;
            STATE.config.size = parseInt(document.getElementById('mapSize').value);
            STATE.config.corridorWidth = parseInt(document.getElementById('corridorWidth').value);
            STATE.config.seed = document.getElementById('seedInput').value || Math.random().toString(36).substr(2);
            document.getElementById('seedInput').value = STATE.config.seed; // Display generated seed
            STATE.config.tileSize = parseInt(document.getElementById('tileSize').value);
            STATE.config.theme = document.getElementById('themeSelect').value;
            STATE.config.waterLevel = parseInt(document.getElementById('waterLevel').value) / 100;
            STATE.config.showRoofs = document.getElementById('showRoofs').checked;
            STATE.config.enableLighting = document.getElementById('enableLighting').checked;
            STATE.config.showGrid = document.getElementById('showGrid').checked;
        }

        // --- Algorithms ---

        function genDungeon() {
            const sz = STATE.config.size;
            const minRoom = 6;
            const maxRoom = 15;
            const cw = STATE.config.corridorWidth;

            // Fill with walls
            for(let y=0; y<sz; y++) for(let x=0; x<sz; x++) STATE.map[y][x] = TILE.WALL;

            const rooms = [];
            const bsp = (x, y, w, h, depth) => {
                if (depth > 5 || (w < 20 && h < 20)) {
                    // Make room
                    const rw = Math.floor(rng() * (w - minRoom - 2)) + minRoom;
                    const rh = Math.floor(rng() * (h - minRoom - 2)) + minRoom;
                    const rx = x + Math.floor(rng() * (w - rw));
                    const ry = y + Math.floor(rng() * (h - rh));
                    
                    // Carve
                    for(let iy=ry; iy<ry+rh; iy++) {
                        for(let ix=rx; ix<rx+rw; ix++) STATE.map[iy][ix] = TILE.FLOOR;
                    }
                    rooms.push({x:rx, y:ry, w:rw, h:rh, cx: Math.floor(rx+rw/2), cy: Math.floor(ry+rh/2)});
                    
                    // Add props
                    decorateRoom(rx, ry, rw, rh, 'dungeon');
                    return;
                }
                
                // Split
                const horz = rng() > 0.5;
                if (horz) {
                    const split = Math.floor(rng() * (h * 0.4)) + Math.floor(h * 0.3);
                    bsp(x, y, w, split, depth+1);
                    bsp(x, y+split, w, h-split, depth+1);
                } else {
                    const split = Math.floor(rng() * (w * 0.4)) + Math.floor(w * 0.3);
                    bsp(x, y, split, h, depth+1);
                    bsp(x+split, y, w-split, h, depth+1);
                }
            };

            bsp(2, 2, sz-4, sz-4, 0);

            // Connect rooms (Minimum Spanning Tree - ish)
            for (let i=0; i<rooms.length-1; i++) {
                const r1 = rooms[i];
                const r2 = rooms[i+1]; // Simple linear connection for BSP leaves
                
                // H corridor
                let xStart = Math.min(r1.cx, r2.cx);
                let xEnd = Math.max(r1.cx, r2.cx);
                for(let x=xStart; x<=xEnd; x++) {
                    for(let w=0; w<cw; w++) STATE.map[r1.cy + w][x] = TILE.FLOOR;
                }
                
                // V corridor
                let yStart = Math.min(r1.cy, r2.cy);
                let yEnd = Math.max(r1.cy, r2.cy);
                for(let y=yStart; y<=yEnd; y++) {
                    for(let w=0; w<cw; w++) STATE.map[y][r2.cx + w] = TILE.FLOOR;
                }
            }
        }

        function genCavern() {
            const sz = STATE.config.size;
            // Init noise
            for(let y=0; y<sz; y++) {
                for(let x=0; x<sz; x++) {
                    if (x===0 || x===sz-1 || y===0 || y===sz-1) STATE.map[y][x] = TILE.WALL;
                    else STATE.map[y][x] = rng() < 0.48 ? TILE.WALL : TILE.FLOOR;
                }
            }

            // Smooth (Cellular Automata)
            for(let i=0; i<5; i++) {
                const next = JSON.parse(JSON.stringify(STATE.map));
                for(let y=1; y<sz-1; y++) {
                    for(let x=1; x<sz-1; x++) {
                        let count = 0;
                        for(let dy=-1; dy<=1; dy++) for(let dx=-1; dx<=1; dx++) {
                            if (STATE.map[y+dy][x+dx] === TILE.WALL) count++;
                        }
                        if (count >= 5) next[y][x] = TILE.WALL;
                        else if (count <= 3) next[y][x] = TILE.FLOOR;
                    }
                }
                STATE.map = next;
            }

            // Add Mushrooms/Lights
            for(let y=0; y<sz; y+=5) for(let x=0; x<sz; x+=5) {
                if (STATE.map[y][x] === TILE.FLOOR && rng() < 0.2) {
                     STATE.lights.push({x: x + 0.5, y: y + 0.5, r: 5, color: '#a020f0', flicker: true});
                     STATE.entities.push({type: 'shroom', x, y});
                }
            }
        }

        function genTown() {
            const sz = STATE.config.size;
            // Fill grass
            for(let y=0; y<sz; y++) for(let x=0; x<sz; x++) STATE.map[y][x] = TILE.GRASS;

            // 1. Roads (Grid perturbed)
            const blockSize = 12;
            for(let y=0; y<sz; y++) {
                for(let x=0; x<sz; x++) {
                    // Main Roads
                    if (x % blockSize === 0 || y % blockSize === 0) {
                        // Wobbly roads
                        if (rng() < 0.9) STATE.map[y][x] = TILE.ROAD;
                    }
                }
            }
            // Cleanup disconnected road bits (simple smoothing)
            
            // 2. Buildings (Box-in-Box)
            // Find empty grass plots
            for (let y=2; y<sz-blockSize; y+=blockSize) {
                for (let x=2; x<sz-blockSize; x+=blockSize) {
                    if (rng() < 0.7) { // Chance to have building block
                        // Define building bounds (inset from road)
                        const bX = x + 2;
                        const bY = y + 2;
                        const bW = blockSize - 4;
                        const bH = blockSize - 4;
                        
                        buildHouse(bX, bY, bW, bH);
                    } else {
                        // Park
                         STATE.entities.push({type: 'tree', x: x + blockSize/2, y: y + blockSize/2, w:1});
                    }
                }
            }
        }
        
        function genRuins() {
            genDungeon(); // Start with dungeon
            const sz = STATE.config.size;
            // Erode it
            for(let y=1; y<sz-1; y++) {
                for(let x=1; x<sz-1; x++) {
                    if (STATE.map[y][x] === TILE.WALL && rng() < 0.2) STATE.map[y][x] = TILE.FLOOR; // Walls crumble
                    if (STATE.map[y][x] === TILE.FLOOR && rng() < 0.1) STATE.map[y][x] = TILE.GRASS; // Overgrowth
                }
            }
        }

        function buildHouse(x, y, w, h) {
            // 1. Foundation
            for(let iy=y; iy<y+h; iy++) {
                for(let ix=x; ix<x+w; ix++) {
                    // Walls on edge
                    if (iy===y || iy===y+h-1 || ix===x || ix===x+w-1) STATE.map[iy][ix] = TILE.WALL;
                    else STATE.map[iy][ix] = TILE.FLOOR;
                }
            }
            
            // 2. Door (find side facing road?)
            // Simplification: Door on random side
            if (rng() > 0.5) STATE.map[y+h-1][x + Math.floor(w/2)] = TILE.DOOR;
            else STATE.map[y][x + Math.floor(w/2)] = TILE.DOOR;

            // 3. Interior
            const type = rng();
            if (type < 0.5) { // Residence
                STATE.entities.push({type: 'bed', x: x+1, y: y+1});
                STATE.entities.push({type: 'table', x: x+w/2, y: y+h/2});
                STATE.lights.push({x: x+w/2, y: y+h/2, r: 4, color: '#ffaa00', flicker: true});
            } else { // Shop
                 STATE.entities.push({type: 'crate', x: x+1, y: y+1});
                 STATE.entities.push({type: 'crate', x: x+w-2, y: y+1});
            }

            // 4. Roof Data
            STATE.entities.push({type: 'roof', x: x, y: y, w: w, h: h, color: rng()>0.5 ? '#8d4033' : '#5a4a42'});
        }

        function decorateRoom(x, y, w, h, type) {
            // Center Light
            if (w > 4 && h > 4) {
                STATE.lights.push({x: x+w/2, y: y+h/2, r: Math.min(w,h)/1.5, color: '#ff7700', flicker: true});
            }
            
            // Random clutter
            for(let i=0; i<3; i++) {
                const ex = x + 1 + Math.floor(rng()*(w-2));
                const ey = y + 1 + Math.floor(rng()*(h-2));
                STATE.entities.push({type: rng()>0.5?'crate':'rubble', x: ex, y: ey});
            }
        }

        function applyWater() {
            const sz = STATE.config.size;
            const level = STATE.config.waterLevel;
            // Simple perlin-ish noise for water
            for(let y=0; y<sz; y++) {
                for(let x=0; x<sz; x++) {
                    // Fake noise: sin waves
                    const n = (Math.sin(x/10) + Math.cos(y/10) + Math.sin((x+y)/20)) / 3 + 0.5;
                    if (n < level && STATE.map[y][x] !== TILE.WALL) {
                        STATE.map[y][x] = TILE.WATER;
                    }
                }
            }
        }


        // --- Rendering System (The Mega-Map Optimization) ---

        function renderStaticLayer() {
            // 1. Resize Static Canvas
            const sz = STATE.config.size;
            const ts = STATE.config.tileSize;
            staticCanvas.width = sz * ts;
            staticCanvas.height = sz * ts;

            // 2. Draw Base Tiles
            const theme = THEMES[STATE.config.theme];
            
            for(let y=0; y<sz; y++) {
                for(let x=0; x<sz; x++) {
                    const tile = STATE.map[y][x];
                    const px = x * ts;
                    const py = y * ts;
                    
                    switch(tile) {
                        case TILE.VOID: staticCtx.fillStyle = '#000'; break;
                        case TILE.FLOOR: staticCtx.fillStyle = theme.floor; break;
                        case TILE.WALL: staticCtx.fillStyle = theme.wall; break;
                        case TILE.WATER: staticCtx.fillStyle = theme.water; break;
                        case TILE.GRASS: staticCtx.fillStyle = theme.grass; break;
                        case TILE.ROAD: staticCtx.fillStyle = theme.road; break;
                        case TILE.DOOR: staticCtx.fillStyle = '#4a3b2a'; break; // Wood
                    }
                    staticCtx.fillRect(px, py, ts, ts);

                    // Texturing Detail
                    if (tile === TILE.WALL) {
                        // Top edge highlight
                        staticCtx.fillStyle = theme.wallTop;
                        staticCtx.fillRect(px, py, ts, 4);
                        // Fake AO shadow at bottom
                        staticCtx.fillStyle = 'rgba(0,0,0,0.5)';
                        staticCtx.fillRect(px, py+ts-4, ts, 4);
                    } else if (tile === TILE.FLOOR || tile === TILE.GRASS) {
                         // Noise texture
                         if (rng() > 0.8) {
                             staticCtx.fillStyle = 'rgba(0,0,0,0.1)';
                             staticCtx.fillRect(px + rng()*ts/2, py + rng()*ts/2, 4, 4);
                         }
                    }
                }
            }
        }

        // Main Loop (60 FPS)
        function loop() {
            requestAnimationFrame(loop);
            renderViewport();
        }

        function renderViewport() {
            // 1. Clear
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);

            const ts = STATE.config.tileSize;
            const cx = STATE.cam.x;
            const cy = STATE.cam.y;
            const z = STATE.cam.z;

            // 2. Draw Static Layer (Clipped)
            // Math: sourceX, sourceY, sWidth, sHeight, destX, destY, dWidth, dHeight
            // We draw the whole visible area
            
            ctx.save();
            // Apply Transform
            ctx.translate(mainCanvas.width/2, mainCanvas.height/2);
            ctx.scale(z, z);
            ctx.translate(cx, cy);

            // Optimization: Draw Image is fast, even for big canvases
            ctx.drawImage(staticCanvas, 0, 0);

            // 3. Draw Dynamic Entities
            renderEntities(ctx, ts);

            // 4. Lighting Pass
            if (STATE.config.enableLighting) renderLighting(ctx);
            
            // 5. Grid Overlay
            if (STATE.config.showGrid) {
                ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                const mapPx = STATE.config.size * ts;
                for(let x=0; x<=mapPx; x+=ts) { ctx.moveTo(x, 0); ctx.lineTo(x, mapPx); }
                for(let y=0; y<=mapPx; y+=ts) { ctx.moveTo(0, y); ctx.lineTo(mapPx, y); }
                ctx.stroke();
            }

            ctx.restore();
        }

        function renderEntities(ctx, ts) {
            STATE.entities.forEach(e => {
                const px = e.x * ts;
                const py = e.y * ts;
                
                // Roof Toggle
                if (e.type === 'roof') {
                    if (STATE.config.showRoofs) {
                        ctx.fillStyle = e.color;
                        ctx.fillRect(px, py, e.w*ts, e.h*ts);
                        // Ridge
                        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(px, py); ctx.lineTo(px+e.w*ts, py+e.h*ts);
                        ctx.moveTo(px+e.w*ts, py); ctx.lineTo(px, py+e.h*ts);
                        ctx.stroke();
                    }
                    return; // Skip drawing interiors under roof? No, drawn before roof.
                }

                // Props
                if (e.type === 'crate') {
                    ctx.fillStyle = '#8d6e63';
                    ctx.fillRect(px+10, py+10, ts-20, ts-20);
                    ctx.strokeStyle = '#3e2723';
                    ctx.strokeRect(px+10, py+10, ts-20, ts-20);
                } else if (e.type === 'bed') {
                    ctx.fillStyle = '#ef9a9a';
                    ctx.fillRect(px+5, py+10, ts-10, ts-20);
                    ctx.fillStyle = '#fff'; // Pillow
                    ctx.fillRect(px+5, py+10, ts-10, 10);
                } else if (e.type === 'tree') {
                    ctx.fillStyle = 'rgba(0,0,0,0.4)';
                    ctx.beginPath(); ctx.arc(px+ts/2+5, py+ts/2+5, ts/2, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#388e3c';
                    ctx.beginPath(); ctx.arc(px+ts/2, py+ts/2, ts/2, 0, Math.PI*2); ctx.fill();
                }
            });
        }

        function renderLighting(ctx) {
            // Global Darkness
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = 'rgba(0,0,0, 0.6)'; // Ambient light level
            ctx.fillRect(0, 0, staticCanvas.width, staticCanvas.height);

            // Lights
            ctx.globalCompositeOperation = 'lighter'; // Additive blending
            const time = Date.now() / 200;

            STATE.lights.forEach(l => {
                // Flicker
                const r = l.flicker ? l.r * STATE.config.tileSize * (0.9 + Math.sin(time + l.x)*0.1) : l.r * STATE.config.tileSize;
                const x = l.x * STATE.config.tileSize;
                const y = l.y * STATE.config.tileSize;

                const grad = ctx.createRadialGradient(x, y, r*0.1, x, y, r);
                grad.addColorStop(0, l.color);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI*2);
                ctx.fill();
            });

            ctx.globalCompositeOperation = 'source-over'; // Reset
        }


        // --- Interaction Handlers ---

        const vp = document.getElementById('viewport');
        vp.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomSpeed = 0.001;
            STATE.cam.z -= e.deltaY * zoomSpeed;
            STATE.cam.z = Math.max(0.1, Math.min(3, STATE.cam.z));
        });

        vp.addEventListener('mousedown', e => {
            STATE.isDragging = true;
            STATE.lastMouse = { x: e.clientX, y: e.clientY };
        });
        
        window.addEventListener('mousemove', e => {
            if (STATE.isDragging) {
                const dx = e.clientX - STATE.lastMouse.x;
                const dy = e.clientY - STATE.lastMouse.y;
                STATE.lastMouse = { x: e.clientX, y: e.clientY };
                STATE.cam.x += dx / STATE.cam.z;
                STATE.cam.y += dy / STATE.cam.z;
            }
        });

        window.addEventListener('mouseup', () => STATE.isDragging = false);

        // UI Events
        function setupControls() {
            document.getElementById('generateBtn').onclick = generate;
            document.getElementById('rndSeedBtn').onclick = () => {
                document.getElementById('seedInput').value = Math.random().toString(36).substr(2, 8);
            };
            
            // Accordion
            const acc = document.getElementsByClassName("accordion");
            for (let i = 0; i < acc.length; i++) {
                acc[i].addEventListener("click", function() {
                    this.classList.toggle("active");
                    var panel = this.nextElementSibling;
                    if (panel.style.maxHeight) {
                        panel.style.maxHeight = null;
                    } else {
                        panel.style.maxHeight = panel.scrollHeight + "px";
                    } 
                });
            }
            
            // Live toggles (don't regen, just redraw)
            ['showRoofs', 'showGrid', 'enableLighting'].forEach(id => {
                document.getElementById(id).onchange = () => {
                    STATE.config[id] = document.getElementById(id).checked;
                };
            });

            // Export
            document.getElementById('exportBtn').onclick = () => {
                const link = document.createElement('a');
                link.download = 'foundry-map.webp';
                link.href = staticCanvas.toDataURL('image/webp', 0.8);
                link.click();
            };

             document.getElementById('jsonBtn').onclick = () => {
                const data = JSON.stringify(STATE.map);
                const blob = new Blob([data], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'map-data.json';
                link.click();
            };
            
            // Slider values
            document.getElementById('corridorWidth').oninput = function() {
                document.getElementById('corridorVal').innerText = this.value;
            }
        }

        // Boot
        init();

    </script>
</body>
</html>